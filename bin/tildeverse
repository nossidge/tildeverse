#!/usr/bin/env ruby

require_relative '../lib/tildeverse'

module Tildeverse
  ##
  # Define the commands that are possible through the CLI
  #
  class Bin
    attr_reader :argv

    def initialize(argv)
      @argv = argv
    end

    ##
    # Use the arguments to decide which function to perform
    #
    def run
      opt_f = !argv.delete('-f').nil?
      opt_p = !argv.delete('-p').nil?
      opt_j = !argv.delete('-j').nil?
      opt_h = !argv.delete('-h').nil?
      tildeverse_help and return if opt_h

      case argv[0]
      when nil, 'help', '--help', '?'
        tildeverse_help
      when 'scrape'
        tildeverse_scrape
      when 'fetch'
        tildeverse_fetch
      when 'patch'
        tildeverse_patch
      when 'new'
        tildeverse_new
      when 'json'
        tildeverse_json(opt_p)
      when 'sites', 'boxes', 'servers'
        tildeverse_sites(argv[1], opt_f, opt_j, opt_p)
      when 's', 'b', 'site', 'box', 'server'
        tildeverse_site(argv[1], opt_f, opt_j, opt_p)
      else
        tildeverse_else(argv[0], opt_f, opt_j, opt_p)
      end
    end

    ##
    # $ tildeverse
    #
    # Display help info by default
    #
    def tildeverse_help
      puts <<-HELP.gsub(/^ {8}/, '')
          Usage: tildeverse <command> [subcommand]

        $ tildeverse scrape
          Scrape the user list of each box, and generate the JSON files

        $ tildeverse fetch
          Fetch data from tilde.town/~nossidge/tildeverse/tildeverse.json

        $ tildeverse patch
          Run this after you have done manual user tagging in the input JSON
          It will update the output JSON without doing the full site-scrape

        $ tildeverse new
          See if there have been any additions by ~pfhawkins

        $ tildeverse json [-p]
          Write the JSON file to standard out
          -p switch will output JSON in pretty format

        $ tildeverse sites [regex] [-f] [-j -p]
          List all online sites in the Tildeverse
          'regex' argument filters URLs by regex
          -f switch will output all fields in table form
          -j switch will output as JSON
          -p switch will output JSON in pretty format

        $ tildeverse site [regex] [-f] [-j -p]
          List all users for the specified Tildebox
          'regex' argument filters URLs by regex
          -f switch will output all fields in table form
          -j switch will output as JSON
          -p switch will output JSON in pretty format

        $ tildeverse [regex] [-f] [-j -p]
          List all the users by URL
          'regex' argument filters URLs by regex
          -f switch will output all fields in table form
          -j switch will output as JSON
          -p switch will output JSON in pretty format
      HELP
      true
    end

    ##
    # $ tildeverse scrape
    #
    # Scrape the user list of each box, and generate the JSON files
    #
    def tildeverse_scrape
      Tildeverse.scrape
    end

    ##
    # $ tildeverse fetch
    #
    # Fetch data from tilde.town/~nossidge/tildeverse/tildeverse.json
    #
    def tildeverse_fetch
      Tildeverse.fetch
    end

    ##
    # $ tildeverse patch
    #
    # Run this after you have done manual user tagging in the input JSON
    # It will update the output JSON without doing the full site-scrape
    #
    def tildeverse_patch
      Tildeverse.patch
    end

    ##
    # $ tildeverse new
    #
    # See if there have been any additions by ~pfhawkins
    #
    def tildeverse_new
      Tildeverse::PFHawkins.new.puts_if_new
    end

    ##
    # $ tildeverse json [-p]
    #
    # Write the JSON file to standard out
    # -p switch will output in pretty format
    #
    def tildeverse_json(opt_p)
      obj = Tildeverse.data.serialize_tildeverse_json
      puts opt_p ? JSON.pretty_generate(obj) : obj.to_json
    end

    ##
    # $ tildeverse sites [regex] [-f] [-j -p]
    #
    # List all online sites in the Tildeverse
    # 'regex' argument filters site URLs by regex
    # -f switch will output all fields in table form
    # -j switch will output as JSON
    # -p switch will output JSON in pretty format
    #
    def tildeverse_sites(argv1, opt_f, opt_j, opt_p)
      sites = Tildeverse.sites.select(&:online?)
      sites.select! { |i| i.root[Regexp.new(argv1)] } if argv1

      if opt_f
        header = %w[NAME URL USERS]
        output = [header] + sites.map do |site|
          [
            site.name,
            site.root,
            site.users.count
          ]
        end
        puts format_in_columns(output, [2])

      elsif opt_j
        obj = Tildeverse.data.serialize_sites(sites)
        puts opt_p ? JSON.pretty_generate(obj) : obj.to_json

      else
        puts sites.map(&:name)
      end
    end

    ##
    # $ tildeverse site [regex] [-f] [-j -p]
    #
    # List all users for the specified Tildebox
    # 'regex' argument filters site URLs by regex
    # -f switch will output all fields in table form
    # -j switch will output as JSON
    # -p switch will output JSON in pretty format
    #
    def tildeverse_site(argv1, opt_f, opt_j, opt_p)
      sites = Tildeverse.sites.select(&:online?)
      sites.select! { |i| i.root[Regexp.new(argv1)] } if argv1
      users = sites.map { |i| i.users }.flatten

      output = output_users(users, opt_f, opt_j, opt_p)
      puts (output || users.map(&:name))
    end

    ##
    # $ tildeverse [regex] [-f] [-j -p]
    #
    # List all the users by URL
    # 'regex' argument filters user URLs by regex
    # -f switch will output all fields in table form
    # -j switch will output as JSON
    # -p switch will output JSON in pretty format
    #
    def tildeverse_else(argv1, opt_f, opt_j, opt_p)
      users = Tildeverse.users
      users.select! { |i| i.url[Regexp.new(argv1)] } if argv1

      output = output_users(users, opt_f, opt_j, opt_p)
      puts (output || users.map(&:url))
    end

    private

    ##
    # Output a list of users in a consistant way
    #
    # @return [String] text to be put to stdout
    #
    def output_users(users, opt_f, opt_j, opt_p)
      if opt_f
        header = %w[SITE NAME URL MODIFIED TAGGED TAGS]
        output = [header] + users.map do |user|
          [
            user.site.name,
            user.name,
            user.url,
            user.modified_date.split('T').first,
            user.tagged || '-',
            user.tags.join(' ')
          ]
        end
        format_in_columns(output)

      elsif opt_j
        obj = Tildeverse.data.serialize_users(users)
        opt_p ? JSON.pretty_generate(obj) : obj.to_json
      end
    end

    ##
    # Format a 2D array for output to console
    # https://stackoverflow.com/a/11747678/139299
    #
    # @param [Array<Array<String>>] array
    # @param [Array<Integer>] rjust
    #   Elements that should be right-justified
    #   Default is left-justified
    #
    def format_in_columns(array, rjust = [])
      #
      # Figure out max lengths, to use as the width of each column.
      max_lengths = array[0].map(&:length)
      array.each do |row|
        row.each_with_index do |e, i|
          s = e.size
          max_lengths[i] = s if s > max_lengths[i]
        end
      end

      # Format each row as one long string.
      array.map do |row|
        format = max_lengths.map.with_index do |value, index|
          just = rjust.include?(index) ? '' : '-'
          "%#{just}#{value}s"
        end
        format.join(' ' * 2) % row
      end
    end
  end
end

##
# Run the damn thing!
#
Tildeverse::Bin.new(ARGV).run
